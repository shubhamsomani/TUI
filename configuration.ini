[start]
0 = start of section
1 = Classic API Configuration
2 = CONFIGURE_MAXIMUM_TASKS
3 = Unsigned integer (@code{uint32_t}).
4 = Zero or positive.
5 =  The default for this field is 0. 
6 =  @code{CONFIGURE_MAXIMUM_TASKS} is the maximum number of Classic API Tasks that can be concurrently active. 
7 =  This object class can be configured in unlimited allocation mode.  The calculations for the required memory in the RTEMS Workspace for tasks assume that each task has a minimum stack size and has floating point support enabled.  The configuration parameter @code{CONFIGURE_EXTRA_TASK_STACKS} is used to specify task stack requirements @b{ABOVE} the minimum size required.  See @ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum} for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}.  The maximumm number of POSIX threads is specified by @code{CONFIGURE_MAXIMUM_POSIX_THREADS}. @c XXX - Add xref to CONFIGURE_MAXIMUM_POSIX_THREADS.  A future enhancement to @code{<rtems/confdefs.h>} could be to eliminate the assumption that all tasks have floating point enabled. This would require the addition of a new configuration parameter to specify the number of tasks which enable floating point support. 
8 = CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS
9 = Boolean feature macro.
10 = Defined or undefined.
11 =  By default, this is not defined and Classic API Notepads are supported. 
12 =  @code{CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS} should be defined if the user does not want to have support for Classic API Notepads in their application. 
13 =  Disabling Classic API Notepads saves the allocation of sixteen (16) thirty-two bit integers. This saves sixty-four bytes per task/thread plus the allocation overhead. Notepads are rarely used in applications and this can save significant memory in a low RAM system. 
14 = CONFIGURE_MAXIMUM_TIMERS
15 = Unsigned integer (@code{uint32_t}).
16 = Zero or positive.
17 =  The default for this field is 0. 
18 =  @code{CONFIGURE_MAXIMUM_TIMERS} is the maximum number of Classic API Timers that can be concurrently active. 
19 =  This object class can be configured in unlimited allocation mode. 
20 = CONFIGURE_MAXIMUM_SEMAPHORES
21 = Unsigned integer (@code{uint32_t}).
22 = Zero or positive.
23 =  The default for this field is 0. 
24 =  @code{CONFIGURE_MAXIMUM_SEMAPHORES} is the maximum number of Classic API Semaphores that can be concurrently active. 
25 =  This object class can be configured in unlimited allocation mode. 
26 = CONFIGURE_MAXIMUM_MESSAGE_QUEUES
27 = Unsigned integer (@code{uint32_t}).
28 = Zero or positive.
29 =  The default for this field is 0. 
30 =  @code{CONFIGURE_MAXIMUM_MESSAGE_QUEUES} is the maximum number of Classic API Message Queues that can be concurrently active. 
31 =  This object class can be configured in unlimited allocation mode. 
32 = CONFIGURE_MAXIMUM_BARRIERS
33 = Unsigned integer (@code{uint32_t}).
34 = Zero or positive.
35 =  The default for this field is 0. 
36 =  @code{CONFIGURE_MAXIMUM_BARRIERS} is the maximum number of Classic API Barriers that can be concurrently active. 
37 =  This object class can be configured in unlimited allocation mode. 
38 = CONFIGURE_MAXIMUM_PERIODS
39 = Unsigned integer (@code{uint32_t}).
40 = Zero or positive.
41 =  The default for this field is 0. 
42 =  @code{CONFIGURE_MAXIMUM_PERIODS} is the maximum number of Classic API Periods that can be concurrently active. 
43 =  This object class can be configured in unlimited allocation mode. 
44 = CONFIGURE_MAXIMUM_PARTITIONS
45 = Unsigned integer (@code{uint32_t}).
46 = Zero or positive.
47 =  The default for this field is 0. 
48 =  @code{CONFIGURE_MAXIMUM_PARTITIONS} is the maximum number of Classic API Partitions that can be concurrently active. 
49 =  This object class can be configured in unlimited allocation mode. 
50 = CONFIGURE_MAXIMUM_REGIONS
51 = Unsigned integer (@code{uint32_t}).
52 = Zero or positive.
53 =  The default for this field is 0. 
54 =  @code{CONFIGURE_MAXIMUM_REGIONS} is the maximum number of Classic API Regions that can be concurrently active. 
55 =  None. 
56 = CONFIGURE_MAXIMUM_PORTS
57 = Unsigned integer (@code{uint32_t}).
58 = Zero or positive.
59 =  The default for this field is 0. 
60 =  @code{CONFIGURE_MAXIMUM_PORTS} is the maximum number of Classic API Ports that can be concurrently active. 
61 =  This object class can be configured in unlimited allocation mode. 
62 = CONFIGURE_MAXIMUM_USER_EXTENSIONS
63 = Unsigned integer (@code{uint32_t}).
64 = Zero or positive.
65 =  The default for this field is 0. 
66 =  @code{CONFIGURE_MAXIMUM_USER_EXTENSIONS} is the maximum number of Classic API User Extensions that can be concurrently active. 
67 =  This object class can be configured in unlimited allocation mode. 
68 = start of section
69 = Classic API Initialization Tasks Table Configuration
70 = CONFIGURE_RTEMS_INIT_TASKS_TABLE
71 = Boolean feature macro.
72 = Defined or undefined.
73 =  This is not defined by default. 
74 =  @code{CONFIGURE_RTEMS_INIT_TASKS_TABLE} is defined if the user wishes to use a Classic RTEMS API Initialization Task Table. The table built by @code{<rtems/confdefs.h>} specifies the parameters for a single task. This is sufficient for applications which initialization the system from a single task.  By default, this field is not defined as the user MUST select their own API for initialization tasks. 
75 =  The application may choose to use the initialization tasks or threads table from another API.  A compile time error will be generated if the user does not configure any initialization tasks or threads. 
76 = CONFIGURE_INIT_TASK_ENTRY_POINT
77 = Task entry function pointer (@code{rtems_task_entry}).
78 = Valid task entry function pointer.
79 =  By default the value is Init . 
80 =  @code{CONFIGURE_INIT_TASK_ENTRY_POINT} is the entry point (a.k.a. function name) of the single initialization task defined by the Classic API Initialization Tasks Table. 
81 =  The user must implement the function @code{Init} or the function name provided in this configuration parameter. 
82 = CONFIGURE_INIT_TASK_NAME
83 = RTEMS Name (@code{rtems_name}).
84 = Any value.
85 =  By default the value is rtems_build_name( 'U', 'I', '1', ' ' ) . 
86 =  @code{CONFIGURE_INIT_TASK_NAME} is the name of the single initialization task defined by the Classic API Initialization Tasks Table. 
87 =  None. 
88 = CONFIGURE_INIT_TASK_STACK_SIZE
89 = Unsigned integer (@code{size_t}).
90 = Zero or positive.
91 =  By default value is the configured minimum stack size. 
92 =  @code{CONFIGURE_INIT_TASK_STACK_SIZE} is the stack size of the single initialization task defined by the Classic API Initialization Tasks Table. 
93 =  If the stack size specified is greater than the configured minimum, it must be accounted for in @code{CONFIGURE_EXTRA_TASK_STACKS}. See @ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum} for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}. 
94 = CONFIGURE_INIT_TASK_PRIORITY
95 = RTEMS Task Priority (@code{rtems_task_priority}).
96 = One (1) to CONFIGURE_MAXIMUM_PRIORITY.
97 =  By default the value is one (1) which is the highest priority in the Classic API. 
98 =  @code{CONFIGURE_INIT_TASK_PRIORITY} is the initial priority of the single initialization task defined by the Classic API Initialization Tasks Table. 
99 =  None. 
100 = CONFIGURE_INIT_TASK_ATTRIBUTES
101 = RTEMS Attributes (@code{rtems_attribute}).
102 = Valid task attribute sets.
103 =  By default the tvalue is RTEMS_DEFAULT_ATTRIBUTES . 
104 =  @code{CONFIGURE_INIT_TASK_ATTRIBUTES} is the task attributes of the single initialization task defined by the Classic API Initialization Tasks Table. 
105 =  None. 
106 = CONFIGURE_INIT_TASK_INITIAL_MODES
107 = RTEMS Mode (@code{rtems_mode}).
108 = Valid task mode sets.
109 =  By default the value is RTEMS_NO_PREEMPT . 
110 =  @code{CONFIGURE_INIT_TASK_INITIAL_MODES} is the initial execution mode of the single initialization task defined by the Classic API Initialization Tasks Table. 
111 =  None. 
112 = CONFIGURE_INIT_TASK_ARGUMENTS
113 = RTEMS Task Argument (@code{rtems_task_argument}).
114 = Complete range of the type.
115 =  By default the value is 0. 
116 =  @code{CONFIGURE_INIT_TASK_ARGUMENTS} is the task argument of the single initialization task defined by the Classic API Initialization Tasks Table. 
117 =  None. 
118 = CONFIGURE_HAS_OWN_INIT_TASK_TABLE
119 = Boolean feature macro.
120 = Defined or undefined.
121 =  This is not defined by default. 
122 =  @code{CONFIGURE_HAS_OWN_INIT_TASK_TABLE} is defined if the user wishes to define their own Classic API Initialization Tasks Table.  This table should be named @code{Initialization_tasks}. 
123 =  This is a seldom used configuration parameter. The most likely use case is when an application desires to have more than one initialization task. 
124 = start of section
125 = POSIX API Configuration
126 = CONFIGURE_MAXIMUM_POSIX_THREADS
127 = Unsigned integer (@code{uint32_t}).
128 = Zero or positive.
129 =  The default for this field is 0. 
130 =  @code{CONFIGURE_MAXIMUM_POSIX_THREADS} is the maximum number of POSIX API Threads that can be concurrently active. 
131 =  This object class can be configured in unlimited allocation mode.  This calculations for the required memory in the RTEMS Workspace for threads assume that each thread has a minimum stack size and has floating point support enabled.  The configuration parameter @code{CONFIGURE_EXTRA_TASK_STACKS} is used to specify thread stack requirements @b{ABOVE} the minimum size required. See @ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum} for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}.  The maximum number of Classic API Tasks is specified by @code{CONFIGURE_MAXIMUM_TASKS}.  All POSIX threads have floating point enabled.  @c XXX - Add xref to CONFIGURE_MAXIMUM_TASKS. 
132 = CONFIGURE_MAXIMUM_POSIX_MUTEXES
133 = Unsigned integer (@code{uint32_t}).
134 = Zero or positive.
135 =  The default for this field is 0. 
136 =  @code{CONFIGURE_MAXIMUM_POSIX_MUTEXES} is the maximum number of POSIX API Mutexes that can be concurrently active. 
137 =  This object class can be configured in unlimited allocation mode. 
138 = CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES
139 = Unsigned integer (@code{uint32_t}).
140 = Zero or positive.
141 =  The default for this field is 0. 
142 =  @code{CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES} is the maximum number of POSIX API Condition Variables that can be concurrently active. 
143 =  This object class can be configured in unlimited allocation mode. 
144 = CONFIGURE_MAXIMUM_POSIX_KEYS
145 = Unsigned integer (@code{uint32_t}).
146 = Zero or positive.
147 =  The default for this field is 0. 
148 =  @code{CONFIGURE_MAXIMUM_POSIX_KEYS} is the maximum number of POSIX API Keys that can be concurrently active. 
149 =  This object class can be configured in unlimited allocation mode.  @c XXX - Key pairs 
150 = CONFIGURE_MAXIMUM_POSIX_TIMERS
151 = Unsigned integer (@code{uint32_t}).
152 = Zero or positive.
153 =  The default for this field is 0. 
154 =  @code{CONFIGURE_MAXIMUM_POSIX_TIMERS} is the maximum number of POSIX API Timers that can be concurrently active. 
155 =  This object class can be configured in unlimited allocation mode. 
156 = CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS
157 = Unsigned integer (@code{uint32_t}).
158 = Zero or positive.
159 =  The default for this field is 0. 
160 =  @code{CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS} is the maximum number of POSIX API Queued Signals that can be concurrently active. 
161 =  None. 
162 = CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES
163 = Unsigned integer (@code{uint32_t}).
164 = Zero or positive.
165 =  The default for this field is 0. 
166 =  @code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES} is the maximum number of POSIX API Message Queues that can be concurrently active. 
167 =  This object class can be configured in unlimited allocation mode.  @c XXX - memory for buffers note 
168 = CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS
169 = Unsigned integer (@code{uint32_t}).
170 = greater than or equal to @code{CONFIGURE_MAXIMUM_POSIX_MESSAGES_QUEUES}
171 =  The default for this field is 0. 
172 =  @code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS} is the maximum number of POSIX API Message Queue Descriptors that can be concurrently active. 
173 =  This object class can be configured in unlimited allocation mode.  @code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS} should be greater than or equal to @code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES}. 
174 = CONFIGURE_MAXIMUM_POSIX_SEMAPHORES
175 = Unsigned integer (@code{uint32_t}).
176 = Zero or positive.
177 =  The default for this field is 0. 
178 =  @code{CONFIGURE_MAXIMUM_POSIX_SEMAPHORES} is the maximum number of POSIX API Semaphores that can be concurrently active. 
179 =  None. 
180 = CONFIGURE_MAXIMUM_POSIX_BARRIERS
181 = Unsigned integer (@code{uint32_t}).
182 = Zero or positive.
183 =  The default for this field is 0. 
184 =  @code{CONFIGURE_MAXIMUM_POSIX_BARRIERS} is the maximum number of POSIX API Barriers that can be concurrently active. 
185 =  This object class can be configured in unlimited allocation mode. 
186 = CONFIGURE_MAXIMUM_POSIX_SPINLOCKS
187 = Unsigned integer (@code{uint32_t}).
188 = Zero or positive.
189 =  The default for this field is 0. 
190 =  @code{CONFIGURE_MAXIMUM_POSIX_SPINLOCKS} is the maximum number of POSIX API Spinlocks that can be concurrently active. 
191 =  This object class can be configured in unlimited allocation mode. 
192 = CONFIGURE_MAXIMUM_POSIX_RWLOCKS
193 = Unsigned integer (@code{uint32_t}).
194 = Zero or positive.
195 =  The default for this field is 0. 
196 =  @code{CONFIGURE_MAXIMUM_POSIX_RWLOCKS} is the maximum number of POSIX API Read/Write Locks that can be concurrently active. 
197 =  This object class can be configured in unlimited allocation mode. 
198 = start of section
199 = POSIX Initialization Threads Table Configuration
200 = CONFIGURE_POSIX_INIT_THREAD_TABLE
201 = Boolean feature macro.
202 = Defined or undefined.
203 =  By default, this field is not defined as the user MUST select their own API for initialization tasks. 
204 =  @code{CONFIGURE_POSIX_INIT_THREAD_TABLE} is defined if the user wishes to use a POSIX API Initialization Threads Table.  The table built by @code{<rtems/confdefs.h>} specifies the parameters for a single thread. This is sufficient for applications which initialization the system from a single task.  By default, this field is not defined as the user MUST select their own API for initialization tasks. 
205 =  The application may choose to use the initialization tasks or threads table from another API.  A compile time error will be generated if the user does not configure any initialization tasks or threads. 
206 = CONFIGURE_POSIX_INIT_THREAD_TABLE
207 = Boolean feature macro.
208 = Defined or undefined.
209 =  By default, this field is not defined as the user MUST select their own API for initialization tasks. 
210 =  @code{CONFIGURE_POSIX_INIT_THREAD_TABLE} is defined if the user wishes to use a POSIX API Initialization Threads Table.  The table built by @code{<rtems/confdefs.h>} specifies the parameters for a single thread. This is sufficient for applications which initialization the system from a single task.  By default, this field is not defined as the user MUST select their own API for initialization tasks. 
211 =  The application may choose to use the initialization tasks or threads table from another API.  A compile time error will be generated if the user does not configure any initialization tasks or threads. 
212 = CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT
213 = POSIX thread function pointer (@code{void *(*entry_point)(void *)}).
214 = Undefined or a valid POSIX thread function pointer.
215 =  By default the value is POSIX_Init . 
216 =  @code{CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT} is the entry point (a.k.a. function name) of the single initialization thread defined by the POSIX API Initialization Threads Table. 
217 =  The user must implement the function @code{POSIX_Init} or the function name provided in this configuration parameter. 
218 = CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE
219 = Unsigned integer (@code{size_t}).
220 = Zero or positive.
221 =  By default value is twice the configured minimum stack size. 
222 =  @code{CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE} is the stack size of the single initialization thread defined by the POSIX API Initialization Threads Table. 
223 =  If the stack size specified is greater than the configured minimum, it must be accounted for in @code{CONFIGURE_EXTRA_TASK_STACKS}. See @ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum} for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}. 
224 = CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE
225 = Boolean feature macro.
226 = Defined or undefined.
227 =  This is not defined by default. 
228 =  @code{CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE} is defined if the user wishes to define their own POSIX API Initialization Threads Table. This table should be named @code{POSIX_Initialization_threads}. 
229 =  This is a seldom used configuration parameter. The most likely use case is when an application desires to have more than one initialization task. 
230 = start of section
231 = Basic System Information
232 = CONFIGURE_UNIFIED_WORK_AREAS
233 = Boolean feature macro.
234 = Defined or undefined.
235 =  By default, this is undefined which specifies that the C Program Heap and the RTEMS Workspace will be separate. 
236 =  When defined, the C Program Heap and the RTEMS Workspace will be one pool of memory.  When not defined, there will be separate memory pools for the RTEMS Workspace and C Program Heap. 
237 =  Having separate pools does have some advantages in the event a task blows a stack or writes outside its memory area. However, in low memory systems the overhead of the two pools plus the potential for unused memory in either pool is very undesirable.  In high memory environments, this is desirable when you want to use the RTEMS "unlimited" objects option.  You will be able to create objects until you run out of all available memory rather then just until you run out of RTEMS Workspace. 
238 = CONFIGURE_MICROSECONDS_PER_TICK
239 = Unsigned integer (@code{uint32_t}).
240 = Positive.
241 =  When not defined, the clock tick quantum is configured to be 10,000 microseconds which is ten (10) milliseconds. 
242 =  This constant is  used to specify the length of time between clock ticks.  When the clock tick quantum value is too low, the system will spend so much time processing clock ticks that it does not have processing time available to perform application work. In this case, the system will become unresponsive.  The lowest practical time quantum varies widely based upon the speed of the target hardware and the architectural overhead associated with interrupts. In general terms, you do not want to configure it lower than is needed for the application.  The clock tick quantum should be selected such that it all blocking and delay times in the application are evenly divisible by it. Otherwise, rounding errors will be introduced which may negatively impact the application. 
243 =  This configuration parameter has no impact if the Clock Tick Device driver is not configured.  There may be BSP specific limits on the resolution or maximum value of a clock tick quantum. 
244 = CONFIGURE_TICKS_PER_TIMESLICE
245 = Unsigned integer (@code{uint32_t}).
246 = Positive.
247 =  If unspecified, this parameter defaults to fifty (50). 
248 =  This configuration parameter specifies the length of the timeslice quantum in ticks for each task. 
249 =  This configuration parameter has no impact if the Clock Tick Device driver is not configured. 
250 = CONFIGURE_MAXIMUM_PRIORITY
251 = Unsigned integer (@code{uint8_t}).
252 = Valid values for this configuration parameter must be one (1) less than
253 =  By default, RTEMS must support 256 priority levels to be compliant with various standards. These priorities range from zero (0) to 255.  Thus, the default value for this field is 255. 
254 =  This configuration parameter specified the maximum numeric priority of any task in the system and one less that the number of priority levels in the system.  Reducing the number of priorities in the system reduces the amount of memory allocated from the RTEMS Workspace. 
255 =  The numerically greatest priority is the logically lowest priority in the system and will thus be used by the IDLE task.  Priority zero (0) is reserved for internal use by RTEMS and is not available to applications.  With some schedulers, reducing the number of priorities can reduce the amount of memory used by the scheduler. For example, the Deterministic Priority Scheduler (DPS) used by default uses three pointers of storage per priority level. Reducing the number of priorities from 256 levels to sixteen (16) can reduce memory usage by about three (3) kilobytes. 
256 = CONFIGURE_MINIMUM_TASK_STACK_SIZE
257 = Unsigned integer (@code{uint32_t}).
258 = Positive.
259 =  When not defined by the application, this is set to the recommended minimum stack size for this processor. 
260 =  The configuration parameter is set to the number of bytes the application wants the minimum stack size to be for every task or thread in the system.  Adjusting this parameter should be done with caution. Examining the actual usage using the Stack Checker Usage Reporting facility is recommended. 
261 =  This parameter can be used to lower the minimum from that recommended. This can be used in low memory systems to reduce memory consumption for stacks. However, this must be done with caution as it could increase the possibility of a blown task stack.  This parameter can be used to increase the minimum from that recommended. This can be used in higher memory systems to reduce the risk of stack overflow without performing analysis on actual consumption. 
262 = CONFIGURE_INTERRUPT_STACK_SIZE
263 = Unsigned integer (@code{uint32_t}).
264 = Positive.
265 =  If not specified, the interrupt stack will be of minimum size. The default value is the configured minimum task stack size. 
266 =  @code{CONFIGURE_INTERRUPT_STACK_SIZE} is set to the size of the interrupt stack.  The interrupt stack size is often set by the BSP but since this memory may be allocated from the RTEMS Workspace, it must be accounted for. 
267 =  In some BSPs, changing this constant does NOT change the size of the interrupt stack, only the amount of memory reserved for it.  Patches which result in this constant only being used in memory calculations when the interrupt stack is intended to be allocated from the RTEMS Workspace would be welcomed by the RTEMS Project. 
268 = CONFIGURE_EXTRA_TASK_STACKS
269 = Unsigned integer (@code{size_t}).
270 = Undefined or positive.
271 =  When this is not defined, the default value is 0. 
272 =  This configuration parameter is set to the number of bytes the applications wishes to add to the task stack requirements calculated by @code{<rtems/confdefs.h>}. 
273 =  This parameter is very important.  If the application creates tasks with stacks larger then the minimum, then that memory is NOT accounted for by @code{<rtems/confdefs.h>}. 
274 = CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY
275 = Boolean feature macro.
276 = Defined or undefined.
277 =  Unless overridden by the BSP, this is not defined by default.  The default is @b{NOT} to zero out the RTEMS Workspace or C Program Heap. 
278 =  This macro indicates whether RTEMS should zero the RTEMS Workspace and C Program Heap as part of its initialization.  If defined, the memory regions are zeroed.  Otherwise, they are not. 
279 =  Zeroing memory can add significantly to system boot time. It is not necessary for RTEMS but is often assumed by support libraries. 
280 = CONFIGURE_STACK_CHECKER_ENABLED
281 = Boolean feature macro.
282 = Defined or undefined.
283 =  By default, this is not defined and thus stack checking is disabled. 
284 =  This configuration parameter is defined when the application wishes to enable run-time stack bounds checking.  
285 =  In 4.9 and older, this configuration parameter was named @code{STACK_CHECKER_ON}.  This increases the time required to create tasks as well as adding overhead to each context switch. 
286 = CONFIGURE_INITIAL_EXTENSIONS
287 = List of user extension initializers (@code{rtems_extensions_table}).
288 = Undefined or a list of one or more user extensions.
289 =  This value is not defined by default. 
290 =  If @code{CONFIGURE_INITIAL_EXTENSIONS} is defined by the application, then this application specific set of initial extensions will be placed in the initial extension table. 
291 =  None. 
292 = start of section
293 = Configuring Custom Task Stack Allocation
294 = CONFIGURE_TASK_STACK_ALLOCATOR_INIT
295 = Function pointer.
296 = Undefined, NULL or valid function pointer.
297 =  The default value for this field is NULL which indicates that task stacks will be allocated from the RTEMS Workspace. 
298 =  @code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT} configures the initialization method for an application or BSP specific task stack allocation implementation. 
299 =  A correctly configured system must configure the following to be consistent:  @itemize @bullet @item @code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT} @item @code{CONFIGURE_TASK_STACK_ALLOCATOR} @item @code{CONFIGURE_TASK_STACK_DEALLOCATOR} @end itemize 
300 = CONFIGURE_TASK_STACK_ALLOCATOR
301 = Function pointer.
302 = Undefined or valid function pointer.
303 =  The default value for this field is _Workspace_Allocate  which indicates that task stacks will be allocated from the RTEMS Workspace. 
304 =  @code{CONFIGURE_TASK_STACK_ALLOCATOR} may point to a user provided routine to allocate task stacks. 
305 =  A correctly configured system must configure the following to be consistent:  @itemize @bullet @item @code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT} @item @code{CONFIGURE_TASK_STACK_ALLOCATOR} @item @code{CONFIGURE_TASK_STACK_DEALLOCATOR} @end itemize 
306 = CONFIGURE_TASK_STACK_DEALLOCATOR
307 = Function pointer.
308 = Undefined or valid function pointer.
309 =  The default value for this field is _Workspace_Free  which indicates that task stacks will be allocated from the RTEMS Workspace. 
310 =  @code{CONFIGURE_TASK_STACK_DEALLOCATOR} may point to a user provided routine to free task stacks. 
311 =  A correctly configured system must configure the following to be consistent:  @itemize @bullet @item @code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT} @item @code{CONFIGURE_TASK_STACK_ALLOCATOR} @item @code{CONFIGURE_TASK_STACK_DEALLOCATOR} @end itemize 
312 = start of section
313 = Configuring Memory for Classic API Message Buffers
314 = CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE
315 = Unsigned integer (@code{size_t}).
316 = Positive.
317 =  None. 
318 =  This is a helper macro which is used to assist in computing the total amount of memory required for message buffers.  Each message queue will have its own configuration with maximum message size and maximum number of pending messages.  The interface for this macro is as follows:  @example CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE(max_messages, size_per) @end example  Where @code{max_messages} is the maximum number of pending messages and @code{size_per} is the size in bytes of the user message. 
319 =  This macro is only used in support of @code{CONFIGURE_MESSAGE_BUFFER_MEMORY}. 
320 = CONFIGURE_MESSAGE_BUFFER_MEMORY
321 = integer summation macro
322 = undefined (zero) or calculation resulting in a positive integer
323 =  By default, this is not defined and zero (0) memory is reserved. 
324 =  This macro is set to the number of bytes the application requires to be reserved for pending Classic API Message Queue buffers. 
325 =  The following illustrates how the help macro @code{CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE} can be used to assist in calculating the message buffer memory required.  In this example, there are two message queues used in this application.  The first message queue has maximum of 24 pending messages with the message structure defined by the type @code{one_message_type}.  The other message queue has maximum of 500 pending messages with the message structure defined by the type @code{other_message_type}.  @example @group #define CONFIGURE_MESSAGE_BUFFER_MEMORY \ (CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \ 24, sizeof(one_message_type) + \ CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \ 500, sizeof(other_message_type) \ ) @end group @end example 
326 = start of section
327 = Seldom Used Configuration Parameters
328 = CONFIGURE_MEMORY_OVERHEAD
329 = Unsigned integer (@code{size_t}).
330 = Zero or positive.
331 =  The default value is 0. 
332 =  Thie parameter is set to the number of kilobytes the application wishes to add to the requirements calculated by @code{<rtems/confdefs.h>}. 
333 =  This configuration parameter should only be used when it is suspected that a bug in @code{<rtems/confdefs.h>} has resulted in an underestimation. Typically the memory allocation will be too low when an application does not account for all message queue buffers or task stacks. 
334 = CONFIGURE_HAS_OWN_CONFIGURATION_TABLE
335 = Boolean feature macro.
336 = Defined or undefined.
337 =  This is not defined by default. 
338 =  This configuration parameter should only be defined if the application is providing their own complete set of configuration tables. 
339 =  None. 
340 = start of section
341 = C Library Support Configuration
342 = CONFIGURE_MALLOC_STATISTICS
343 = Boolean feature macro.
344 = Defined or undefined.
345 =  This is undefined by default and Malloc Statistics are disabled. 
346 =  This configuration parameter is defined when the application wishes to enable the gathering of more detailed statistics on the C Malloc Family of routines. 
347 =  None. 
348 = CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS
349 = Unsigned integer (@code{uint32_t}).
350 = Zero or positive.
351 =  If not defined, the default value is either zero (0) or three if CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER  is defined. Three file descriptors allows RTEMS to support standard input, output, and error I/O streams on 
352 =  This configuration parameter is set to the maximum number of file like objects that can be concurrently open. 
353 =  None. 
354 = CONFIGURE_TERMIOS_DISABLED
355 = Boolean feature macro.
356 = Defined or undefined.
357 =  By default, this is not defined and resources are reserved for the termios functionality. 
358 =  This configuration parameter is defined if the software implementing POSIX termios functionality is not going to be used by this application. 
359 =  The termios support library should not be included in an application executable unless it is directly referenced by the application or a device driver. 
360 = CONFIGURE_NUMBER_OF_TERMIOS_PORTS
361 = Unsigned integer.
362 = Zero or positive.
363 =  By default, this is set to one (1) so a console port can be used. 
364 =  This configuration parameter is set to the number of ports using the termios functionality.  Each concurrently active termios port requires resources. 
365 =  If the application will be using serial ports including, but not limited to, the Console Device (e.g. @code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER}), then it is highly likely that this configuration parameter should NOT be is defined. 
366 = start of section
367 = File System Configuration Parameters
368 = CONFIGURE_HAS_OWN_MOUNT_TABLE
369 = Undefined or an array of type @code{rtems_filesystem_mount_table_t}.
370 = Undefined or an array of type @code{rtems_filesystem_mount_table_t}.
371 =  This is not defined by default. 
372 =  This configuration parameter is defined when the application provides their own filesystem mount table.  The mount table is an array of @code{rtems_filesystem_mount_table_t} entries pointed to by the global variable @code{rtems_filesystem_mount_table}. The number of entries in this table is in an integer variable named @code{rtems_filesystem_mount_table_t}.  @c XXX - is the variable name for the count right? 
373 =  None. @c XXX - Please provide an example 
374 = CONFIGURE_USE_MINIIMFS_AS_BASE_FILESYSTEM
375 = Boolean feature macro.
376 = Defined or undefined.
377 =  This value is not defined by default. If no other root file system configuration parameters are specified, the IMFS will be used as the root file system. 
378 =  This configuration parameter is defined if the application wishes to use the reduced functionality miniIMFS as the root filesystem. This reduced version of the full IMFS does not include the capability to mount other file system types, but it does support directories, device nodes, and symbolic links. 
379 =  The miniIMFS nodes and is smaller in executable code size than the full IMFS. 
380 = CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM
381 = Boolean feature macro.
382 = Defined or undefined.
383 =  This value is not defined by default. If no other root file system configuration parameters are specified, the IMFS will be used as the root file system. 
384 =  This configuration parameter is defined if the application wishes to use the device-only filesytem as the root file system. 
385 =  The device-only filesystem supports only device nodes and is smaller in executable code size than the full IMFS and miniIMFS.  The devFS is comparable in functionality to the pseudo-filesystem name space provided before RTEMS release 4.5.0. 
386 = CONFIGURE_APPLICATION_DISABLE_FILESYSTEM
387 = Boolean feature macro.
388 = Defined or undefined.
389 =  This value is not defined by default. If no other root file system configuration parameters are specified, the IMFS will be used as the root file system. 
390 =  This configuration parameter is defined if the application dose not intend to use any kind of filesystem support. This include the device infrastructure necessary to support @code{printf()}. 
391 =  None. 
392 = start of section
393 = Block Device Cache Configuration
394 = CONFIGURE_APPLICATION_NEEDS_LIBBLOCK
395 = Boolean feature macro.
396 = Defined or undefined.
397 =  This option is not defined by default. 
398 =  Provides a Block Device Cache configuration. 
399 =  Each option of the Block Device Cache configuration can be explicitly set by the user with the configuration options below.  The Block Device Cache is used for example by the RFS and DOSFS file systems. 
400 = CONFIGURE_BDBUF_CACHE_MEMORY_SIZE
401 = Unsigned integer (@code{size_t}).
402 = Positive.
403 =  The default value is 32KiB. 
404 =  Size of the cache memory in bytes. 
405 =  None. 
406 = CONFIGURE_BDBUF_BUFFER_MIN_SIZE
407 = Unsigned integer (@code{uint32_t}).
408 = Positive.
409 =  The default value is 512 bytes. 
410 =  Defines the minimum size of a buffer in bytes. 
411 =  None. 
412 = CONFIGURE_BDBUF_BUFFER_MAX_SIZE
413 = Unsigned integer (@code{uint32_t}).
414 = It must be positive and an integral multiple of the buffer minimum size.
415 =  The default value is 4096 bytes. 
416 =  Defines the maximum size of a buffer in bytes. 
417 =  None. 
418 = CONFIGURE_SWAPOUT_SWAP_PERIOD
419 = Unsigned integer (@code{uint32_t}).
420 = Positive.
421 =  The default value is 250 milliseconds. 
422 =  Defines the swapout task swap period in milliseconds. 
423 =  None. 
424 = CONFIGURE_SWAPOUT_BLOCK_HOLD
425 = Unsigned integer (@code{uint32_t}).
426 = Positive.
427 =  The default value is 1000 milliseconds. 
428 =  Defines the swapout task maximum block hold time in milliseconds. 
429 =  None. 
430 = CONFIGURE_SWAPOUT_TASK_PRIORITY
431 = Task priority (@code{rtems_task_priority}).
432 = Valid task priority.
433 =  The default value is 15. 
434 =  Defines the swapout task priority. 
435 =  None. 
436 = CONFIGURE_BDBUF_MAX_READ_AHEAD_BLOCKS
437 = Unsigned integer (@code{uint32_t}).
438 = Positive.
439 =  The default value is 0. 
440 =  Defines the maximum blocks per read-ahead request. 
441 =  A value of 0 disables the read-ahead task (default).  The read-ahead task will issue speculative read transfers if a sequential access pattern is detected. This can improve the performance on some systems. 
442 = CONFIGURE_BDBUF_MAX_WRITE_BLOCKS
443 = Unsigned integer (@code{uint32_t}).
444 = Positive.
445 =  The default value is 16. 
446 =  Defines the maximum blocks per write request. 
447 =  None. 
448 = CONFIGURE_BDBUF_TASK_STACK_SIZE
449 = Unsigned integer (@code{size_t}).
450 = Zero or positive.
451 =  The default value is the RTEMS minimum stack size. 
452 =  Defines the task stack size of the Block Device Cache tasks in bytes. 
453 =  None. 
454 = CONFIGURE_BDBUF_READ_AHEAD_TASK_PRIORITY
455 = Task priority (@code{rtems_task_priority}).
456 = Valid task priority.
457 =  The default value is 15. 
458 =  Defines the read-ahead task priority. 
459 =  None. 
460 = CONFIGURE_SWAPOUT_WORKER_TASKS
461 = Unsigned integer (@code{size_t}).
462 = Zero or positive.
463 =  The default value is 0. 
464 =  Defines the swapout worker task count. 
465 =  None. 
466 = CONFIGURE_SWAPOUT_WORKER_TASK_PRIORITY
467 = Task priority (@code{rtems_task_priority}).
468 = Valid task priority.
469 =  The default value is 15. 
470 =  Defines the swapout worker task priority. 
471 =  None. 
472 = start of section
473 = BSP Specific Settings
474 = CONFIGURE_DISABLE_BSP_SETTINGS
475 = Boolean feature macro.
476 = Defined or undefined.
477 =  This is not defined by default. 
478 =  All BSP specific configuration settings can be disabled by the application with the @code{CONFIGURE_DISABLE_BSP_SETTINGS} option. 
479 =  None. 
480 = CONFIGURE_MALLOC_BSP_SUPPORTS_SBRK
481 = Boolean feature macro.
482 = Defined or undefined.
483 =  This option is BSP specific. 
484 =  This configuration parameter is defined by a BSP to indicate that it does not allocate all available memory to the C Program Heap used by the Malloc Family of routines.  If defined, when @code{malloc()} is unable to allocate memory, it will call the BSP supplied @code{sbrk()} to obtain more memory. 
485 =  This parameter should not be defined by the application. Only the BSP knows how it allocates memory to the C Program Heap. 
486 = BSP_IDLE_TASK_BODY
487 = Function pointer.
488 = Undefined or valid function pointer.
489 =  This option is BSP specific. 
490 =  If @code{BSP_IDLE_TASK_BODY} is defined by the BSP and @code{CONFIGURE_IDLE_TASK_BODY} is not defined by the application, then this BSP specific idle task body will be used. 
491 =  As it has knowledge of the specific CPU model, system controller logic, and peripheral buses, a BSP specific IDLE task may be capable of turning components off to save power during extended periods of no task activity 
492 = BSP_IDLE_TASK_STACK_SIZE
493 = Unsigned integer (@code{size_t}).
494 = Undefined or positive.
495 =  This option is BSP specific. 
496 =  If @code{BSP_IDLE_TASK_STACK_SIZE} is defined by the BSP and @code{CONFIGURE_IDLE_TASK_STACK_SIZE} is not defined by the application, then this BSP suggested idle task stack size will be used.  
497 =  The order of precedence for configuring the IDLE task stack size is:  @itemize @bullet @item RTEMS default minimum stack size. @item If defined, then @code{CONFIGURE_MINIMUM_TASK_STACK_SIZE}. @item If defined, then the BSP specific @code{BSP_IDLE_TASK_SIZE}. @item If defined, then the application specified @code{CONFIGURE_IDLE_TASK_SIZE}. @end itemize  @c XXX - add cross references to other related values. 
498 = BSP_INITIAL_EXTENSION
499 = List of user extension initializers (@code{rtems_extensions_table}).
500 = Undefined or a list of user extension initializers.
501 =  This option is BSP specific. 
502 =  If @code{BSP_INITIAL_EXTENSION} is defined by the BSP, then this BSP specific initial extension will be placed as the last entry in the initial extension table. 
503 =  None. 
504 = BSP_INTERRUPT_STACK_SIZE
505 = Unsigned integer (@code{size_t}).
506 = Undefined or positive.
507 =  This option is BSP specific. 
508 =  If @code{BSP_INTERRUPT_STACK_SIZE} is defined by the BSP and @code{CONFIGURE_INTERRUPT_STACK_SIZE} is not defined by the application, then this BSP specific interrupt stack size will be used. 
509 =  None. 
510 = BSP_MAXIMUM_DEVICES
511 = Unsigned integer (@code{size_t}).
512 = Undefined or positive.
513 =  This option is BSP specific. 
514 =  If @code{BSP_MAXIMUM_DEVICES} is defined by the BSP and @code{CONFIGURE_MAXIMUM_DEVICES} is not defined by the application, then this BSP specific maximum device count will be used. 
515 =  This option is specific to the device file system (devFS) and should not be confused with the @code{CONFIGURE_MAXIMUM_DRIVERS} option.  This parameter only impacts the devFS and thus is only used by @code{<rtems/confdefs.h>} when @code{CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM} is specified. 
516 = BSP_ZERO_WORKSPACE_AUTOMATICALLY
517 = Boolean feature macro.
518 = Defined or undefined.
519 =  This option is BSP specific. 
520 =  If @code{BSP_ZERO_WORKSPACE_AUTOMATICALLY} is defined by the BSP and @code{CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY} is not defined by the application, then the workspace will be zeroed automatically. 
521 =  Zeroing memory can add significantly to system boot time. It is not necessary for RTEMS but is often assumed by support libraries. 
522 = CONFIGURE_BSP_PREREQUISITE_DRIVERS
523 = List of device driver initializers (@code{rtems_driver_address_table}).
524 = Undefined or array of device drivers.
525 =  This option is BSP specific. 
526 =  @code{CONFIGURE_BSP_PREREQUISITE_DRIVERS} is defined if the BSP has device drivers it needs to include in the Device Driver Table.  This should be defined to the set of device driver entries that will be placed in the table at the @b{FRONT} of the Device Driver Table and initialized before any other drivers @b{INCLUDING} any application prerequisite drivers. 
527 =  @code{CONFIGURE_BSP_PREREQUISITE_DRIVERS} is typically used by BSPs to configure common infrastructure such as bus controllers or probe for devices.  
528 = start of section
529 = Idle Task Configuration
530 = CONFIGURE_IDLE_TASK_BODY
531 = Function pointer.
532 = Undefined or valid function pointer.
533 =  By default, this is not defined. 
534 =  @code{CONFIGURE_IDLE_TASK_BODY} is set to the function name corresponding to the application specific IDLE thread body.  If not specified, the BSP or RTEMS default IDLE thread body will be used. 
535 =  None. 
536 = CONFIGURE_IDLE_TASK_STACK_SIZE
537 = Unsigned integer (@code{size_t}).
538 = Undefined or positive.
539 =  If not specified, the IDLE task will have a stack of the configured minimum stack size. 
540 =  @code{CONFIGURE_IDLE_TASK_STACK_SIZE} is set to the desired stack size for the IDLE task. 
541 =  None. 
542 = CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION
543 = Boolean feature macro.
544 = Defined or undefined.
545 =  By default, this is not the mode of operation and the user is assumed to provide one or more initialization tasks. 
546 =  @code{CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION} is set to indicate that the user has configured @b{NO} user initialization tasks or threads and that the user provided IDLE task will perform application initialization and then transform itself into an IDLE task. 
547 =  If you use this option be careful, the user IDLE task @b{CANNOT} block at all during the initialization sequence.  Further, once application initialization is complete, it must make itself preemptible and enter an IDLE body loop.  The IDLE task must run at the lowest priority of all tasks in the system. 
548 = start of section
549 = Scheduler Algorithm Configuration
550 = CONFIGURE_SCHEDULER_PRIORITY
551 = Boolean feature macro.
552 = Defined or undefined.
553 =  This is the default scheduler and specifying this configuration parameter is redundant. 
554 =  The Deterministic Priority Scheduler is the default scheduler in RTEMS for single core applications and is designed for predictable performance under the highest loads.  It can block or unblock a thread in a constant amount of time.  This scheduler requires a variable amount of memory based upon the number of priorities configured in the system. 
555 =  This scheduler may be explicitly selected by defining @code{CONFIGURE_SCHEDULER_PRIORITY} although this is equivalent to the default behavior. 
556 = CONFIGURE_SCHEDULER_SIMPLE
557 = Boolean feature macro.
558 = Defined or undefined.
559 =  This is not defined by default. 
560 =  When defined, the Simple Priority Scheduler is used at the thread scheduling algorithm. This is an alternative scheduler in RTEMS. It is designed to provide the same task scheduling behaviour as the Deterministic Priority Scheduler while being simpler in implementation and uses less memory for data management.  It maintains a single sorted list of all ready threads.  Thus blocking or unblocking a thread is not a constant time operation with this scheduler.  This scheduler may be explicitly selected by defining @code{CONFIGURE_SCHEDULER_SIMPLE}. 
561 =  This scheduler is appropriate for use in small systems where RAM is limited. 
562 = CONFIGURE_SCHEDULER_EDF
563 = Boolean feature macro.
564 = Defined or undefined.
565 =  This is not defined by default. 
566 =  The Earliest Deadline First Scheduler (EDF) is an alternative scheduler in RTEMS for single core applications. The EDF schedules tasks with dynamic priorities equal to deadlines. The deadlines are declared using only Rate Monotonic manager which handles periodic behavior.  Period is always equal to deadline. If a task does not have any deadline declared or the deadline is cancelled, the task is considered a background task which is scheduled in case no deadline-driven tasks are ready to run.  Moreover, multiple background tasks are scheduled according their priority assigned upon initialization. All ready tasks reside in a single ready queue.  This scheduler may be explicitly selected by defining @code{CONFIGURE_SCHEDULER_EDF}. 
567 =  None.  
568 = CONFIGURE_SCHEDULER_CBS
569 = Boolean feature macro.
570 = Defined or undefined.
571 =  This is not defined by default. 
572 =  The Constant Bandwidth Server Scheduler (CBS) is an alternative scheduler in RTEMS for single core applications. The CBS is a budget aware extension of EDF scheduler. The goal of this scheduler is to ensure temporal isolation of tasks. The CBS is equipped with a set of additional rules and provides with an extensive API.  This scheduler may be explicitly selected by defining @code{CONFIGURE_SCHEDULER_CBS}. @c XXX - add cross reference to API chapter 
573 =  None. 
574 = CONFIGURE_SCHEDULER_SIMPLE_SMP
575 = Boolean feature macro.
576 = Defined or undefined.
577 =  This is not defined by default. 
578 =  The Simple SMP Priority Scheduler is derived from the Simple Priority Scheduler but is capable of scheduling threads across multiple cores. It is designed to provide the same task scheduling behaviour as the Deterministic Priority Scheduler while distributing threads across multiple cores.  Being based upon the Simple Priority Scheduler, it also maintains a single sorted list of all ready threads.  Thus blocking or unblocking a thread is not a constant time operation with this scheduler.  In addition, when allocating threads to cores, the algorithm is not constant time. This algorithm was not designed with efficiency as a primary design goal.  Its primary design goal was to provide an SMP-aware scheduling algorithm that is simple to understand.  In a configuration with SMP enabled at configure time, it may be explicitly selected by defining @code{CONFIGURE_SCHEDULER_SIMPLE_SMP}. 
579 =  This scheduler is only available when RTEMS is configured with SMP support enabled.  This scheduler is currently the default in SMP configurations and is only selected when @code{CONFIGURE_SMP_APPLICATION} is defined. 
580 = CONFIGURE_SCHEDULER_USER
581 = Entry points for scheduler
582 = Undefined or scheduler entry set
583 =  
584 =  RTEMS allows the application to provide its own task/thread scheduling algorithm. In order to do this, one must define @code{CONFIGURE_SCHEDULER_USER} to indicate the application provides its own scheduling algorithm. If @code{CONFIGURE_SCHEDULER_USER} is defined then the following additional macros must be defined:  @itemize @bullet @item @code{CONFIGURE_MEMORY_FOR_SCHEDULER} must be defined with the amount of memory required as a base amount for the scheduler.  @item @code{CONFIGURE_MEMORY_PER_TASK_FOR_SCHEDULER(_tasks)} must be defined as a formula which computes the amount of memory required based upon the number of tasks configured.  @end itemize 
585 =  At this time, the mechanics and requirements for writing a new scheduler are evolving and not fully documented.  It is recommended that you look at the existing Deterministic Priority Scheduler in @code{cpukit/score/src/schedulerpriority*.c} for guidance.  For guidance on the configuration macros, please examine @code{cpukit/sapi/include/confdefs.h} for how these are defined for the Deterministic Priority Scheduler. 
586 = start of section
587 = SMP Specific Configuration Parameters
588 = CONFIGURE_SMP_APPLICATION
589 = Boolean feature macro.
590 = Defined or undefined.
591 =  This is not defined by default. 
592 =  @code{CONFIGURE_SMP_APPLICATION} must be defined if the application is to make use of multiple CPU cores in an SMP target system. 
593 =  None. 
594 = CONFIGURE_SMP_MAXIMUM_PROCESSORS
595 = Boolean feature macro.
596 = Defined or undefined.
597 =  This is not defined by default. 
598 =  @code{CONFIGURE_SMP_MAXIMUM_PROCESSORS} must be set to the number of CPU cores in the SMP configuration. 
599 =  If there are more cores available than configured, the rest will be ignored. 
600 = start of section
601 = Device Driver Table
602 = CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE
603 = List of device driver initializers (@code{rtems_driver_address_table}).
604 = Undefined or array of device drivers.
605 =  By default, this is not defined indicating the <rtems/confdefs.h>  is providing the device driver table. 
606 =  @code{CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE} is defined if the application wishes to provide their own Device Driver Table.  The table must be an array of @code{rtems_driver_address_table} entries named @code{Device_drivers}. 
607 =  It is expected that there the application would only rarely need to do this. 
608 = CONFIGURE_MAXIMUM_DRIVERS
609 = Unsigned integer (@code{uint32_t}).
610 = Zero or positive.
611 =  By default, this is set to the number of device drivers configured using the CONFIGURE_APPLICATIONS_NEEDS_XXX_DRIVER  configuration parameters. 
612 =  @code{CONFIGURE_MAXIMUM_DRIVERS} is defined as the number of device drivers per node. 
613 =  If the application will dynamically install device drivers, then this configuration parameter must be larger than the number of statically configured device drivers. Drivers configured using the @code{CONFIGURE_APPLICATIONS_NEEDS_XXX_DRIVER} configuration parameters are statically installed. 
614 = CONFIGURE_MAXIMUM_DEVICES
615 = Unsigned integer (@code{uint32_t}).
616 = Positive.
617 =  Unless BSP_MAXIMUM_DEVICES  is set by the BSP, the default value for this is set to 4.  If overridden by the BSP the value is set to the value specified by the BSP. 
618 =  @code{CONFIGURE_MAXIMUM_DEVICES} is defined to the number of individual devices that may be registered in the device file system (devFS). 
619 =  This option is specific to the device file system (devFS) and should not be confused with the @code{CONFIGURE_MAXIMUM_DRIVERS} option.  This parameter only impacts the devFS and thus is only used by @code{<rtems/confdefs.h>} when @code{CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM} is specified. 
620 = CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
621 = Boolean feature macro.
622 = Defined or undefined.
623 =  By default, this is not defined. 
624 =  @code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER} is defined if the application wishes to include the Console Device Driver. 
625 =  This device driver is responsible for providing standard input and output using @i{/dev/console}.  BSPs should be constructed in a manner that allows @code{printk()} to work properly without the need for the console driver to be configured. 
626 = CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
627 = Boolean feature macro.
628 = Defined or undefined.
629 =  By default, this is not defined. 
630 =  @code{CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER} is defined if the application wishes to include the Clock Device Driver. 
631 =  This device driver is responsible for providing a regular interrupt which invokes the @code{rtems_clock_tick} directive.  If neither the Clock Driver not Benchmark Timer is enabled and the configuration parameter @code{CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER} is not defined, then a compile time error will occur. 
632 = CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER
633 = Boolean feature macro.
634 = Defined or undefined.
635 =  By default, this is not defined. 
636 =  @code{CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER} is defined if the application wishes to include the Timer Driver.  This device driver is used to benchmark execution times by the RTEMS Timing Test Suites. 
637 =  If neither the Clock Driver not Benchmark Timer is enabled and the configuration parameter @code{CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER} is not defined, then a compile time error will occur. 
638 = CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
639 = Boolean feature macro.
640 = Defined or undefined.
641 =  This is not defined by default. 
642 =  @code{CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER} is defined when the application does @b{NOT} want the Clock Device Driver and is @b{NOT} using the Timer Driver.  The inclusion or exclusion of the Clock Driver must be explicit in user applications. 
643 =  This configuration parameter is intended to prevent the common user error of using the Hello World example as the baseline for an application and leaving out a clock tick source. 
644 = CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER
645 = Boolean feature macro.
646 = Defined or undefined.
647 =  By default, this is not defined. 
648 =  @code{CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER} is defined if the application wishes to include the Real-Time Clock Driver. 
649 =  Most BSPs do not include support for a real-time clock. This is because many boards do not include the required hardware.  If this is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol. 
650 = CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER
651 = Boolean feature macro.
652 = Defined or undefined.
653 =  By default, this is not defined. 
654 =  @code{CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER} is defined if the application wishes to include the Watchdog Driver. 
655 =  Most BSPs do not include support for a watchdog device driver. This is because many boards do not include the required hardware.  If this is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol. 
656 = CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER
657 = Boolean feature macro.
658 = Defined or undefined.
659 =  By default, this is not defined. 
660 =  @code{CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER} is defined if the application wishes to include the BSP's Frame Buffer Device Driver. 
661 =  Most BSPs do not include support for a Frame Buffer Device Driver. This is because many boards do not include the required hardware.  If this is defined and the BSP does not have this device driver, then the user will get a link time error for an undefined symbol. 
662 = CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER
663 = Boolean feature macro.
664 = Defined or undefined.
665 =  By default, this is not defined. 
666 =  @code{CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER} is defined if the application wishes to include the Stub Device Driver. 
667 =  This device driver simply provides entry points that return successful and is primarily a test fixture. It is supported by all BSPs. 
668 = CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS
669 = device driver entry structures
670 = Undefined or set of device driver entry structures
671 =  By default,this is not defined. 
672 =  @code{CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS} is defined if the application has device drivers it needs to include in the Device Driver Table.  This should be defined to the set of device driver entries that will be placed in the table at the @b{FRONT} of the Device Driver Table and initialized before any other drivers @b{EXCEPT} any BSP prerequisite drivers. 
673 =  In some cases, it is used by System On Chip BSPs to support peripheral buses beyond those normally found on the System On Chip. For example, this is used by one RTEMS system which has implemented a SPARC/ERC32 based board with VMEBus. The VMEBus Controller initialization is performed by a device driver configured via this configuration parameter.  @c XXX Add example 
674 = CONFIGURE_APPLICATION_EXTRA_DRIVERS
675 = device driver entry structures
676 = Undefined or set of device driver entry structures
677 =  By default,this is not defined. 
678 =  @code{CONFIGURE_APPLICATION_EXTRA_DRIVERS} is defined if the application has device drivers it needs to include in the Device Driver Table.  This should be defined to the set of device driver entries that will be placed in the table at the @b{END} of the Device Driver Table. 
679 =  None. 
680 = CONFIGURE_APPLICATION_NEEDS_NULL_DRIVER
681 = Boolean feature macro.
682 = Defined or undefined.
683 =  By default,this is not defined. 
684 =  This configuration variable is specified to enable @i{/dev/null} device driver. 
685 =  This device driver is supported by all BSPs. 
686 = CONFIGURE_APPLICATION_NEEDS_ZERO_DRIVER
687 = Boolean feature macro.
688 = Defined or undefined.
689 =  By default,this is not defined. 
690 =  This configuration variable is specified to enable @i{/dev/zero} device driver. 
691 =  This device driver is supported by all BSPs. 
692 = start of section
693 = Multiprocessing Configuration
694 = CONFIGURE_MP_APPLICATION
695 = Boolean feature macro.
696 = Defined or undefined.
697 =  This is not defined by default. 
698 =  This configuration parameter must be defined to indicate that the application intends to be part of a multiprocessing configuration. Additional configuration parameters are assumed to be provided. 
699 =  This has no impact unless RTEMS was configured and built using the @code{--enable-multiprocessing} option. 
700 = CONFIGURE_MP_NODE_NUMBER
701 = Unsigned integer (@code{uint32_t}).
702 = Positive.
703 =  If not defined, it is set to NODE_NUMBER  which is assumed to be set by the compilation environment. 
704 =  @code{CONFIGURE_MP_NODE_NUMBER} is the node number of this node in a multiprocessor system. 
705 =  In the RTEMS Multiprocessing Test Suite, the node number is derived from the Makefile variable @code{NODE_NUMBER}. The same code is compiled with the @code{NODE_NUMBER} set to different values. The test programs behave differently based upon their node number.  
706 = CONFIGURE_MP_MAXIMUM_NODES
707 = Unsigned integer (@code{uint32_t}).
708 = Positive.
709 =  The default is two (2). 
710 =  @code{CONFIGURE_MP_MAXIMUM_NODES} is the maximum number of nodes in a multiprocessor system. 
711 =  None. 
712 = CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS
713 = Unsigned integer (@code{uint32_t}).
714 = Positive.
715 =  The default is 32. 
716 =  @code{CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS} is the maximum number of concurrently active global objects in a multiprocessor system. 
717 =  This value corresponds to the total number of objects which can be created with the @code{RTEMS_GLOBAL} attribute. 
718 = CONFIGURE_MP_MAXIMUM_PROXIES
719 = Unsigned integer (@code{uint32_t}).
720 = Undefined or positive.
721 =  The default is 32. 
722 =  @code{CONFIGURE_MP_MAXIMUM_PROXIES} is the maximum number of concurrently active thread/task proxies on this node in a multiprocessor system. 
723 =  Since a proxy is used to represent a remote task/thread which is blocking on this node. This configuration parameter reflects the maximum number of remote tasks/threads which can be blocked on objects on this node.  @c XXX - add xref to proxy discussion in MP chapter 
724 = CONFIGURE_MP_MPCI_TABLE_POINTER
725 = pointer to @code{rtems_mpci_table}
726 = undefined or valid pointer
727 =  This is not defined by default. 
728 =  @code{CONFIGURE_MP_MPCI_TABLE_POINTER} is the pointer to the MPCI Configuration Table.  The default value of this field is @code{&MPCI_table}. 
729 =  RTEMS provides a Shared Memory MPCI Device Driver which can be used on any Multiprocessor System assuming the BSP provides the proper set of supporting methods. 
730 = CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE
731 = Boolean feature macro.
732 = Defined or undefined.
733 =  This is not defined by default. 
734 =  @code{CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE} is defined if the application wishes to provide their own Multiprocessing Configuration Table.  The generated table is named @code{Multiprocessing_configuration}. 
735 =  This is a configuration parameter which is very unlikely to be used by an application. If you find yourself wanting to use it in an application, please reconsider and discuss this on the RTEMS Users mailing list. 
736 = start of section
737 = Ada Tasks
738 = CONFIGURE_GNAT_RTEMS
739 = Boolean feature macro.
740 = Defined or undefined.
741 =  This is not defined by default. 
742 =  @code{CONFIGURE_GNAT_RTEMS} is defined to inform RTEMS that the GNAT Ada run-time is to be used by the application. 
743 =  This configuration parameter is critical as it makes @code{<rtems/confdefs.h>} configure the resources (POSIX API Threads, Mutexes, Condition Variables, and Keys) used implicitly by the GNAT run-time. 
744 = CONFIGURE_MAXIMUM_ADA_TASKS
745 = Unsigned integer (@code{uint32_t}).
746 = Undefined or positive.
747 =  By default, when CONFIGURE_GNAT_RTEMS  is defined, this is set to 20. 
748 =  @code{CONFIGURE_MAXIMUM_ADA_TASKS} is the number of Ada tasks that can be concurrently active in the system. 
749 =  None. 
750 = CONFIGURE_MAXIMUM_FAKE_ADA_TASKS
751 = Unsigned integer (@code{uint32_t}).
752 = Zero or positive.
753 =  By default, this is undefined which implies zero (0) @i{fake} Ada Tasks. 
754 =  @code{CONFIGURE_MAXIMUM_FAKE_ADA_TASKS} is the number of @i{fake} Ada tasks that can be concurrently active in the system.  A @i{fake} Ada task is a non-Ada task that makes calls back into Ada code and thus implicitly uses the Ada run-time. 
755 =  None. 
756 = CONFIGURE_MAXIMUM_FAKE_ADA_TASKS
757 = Unsigned integer (@code{uint32_t}).
758 = Zero or positive.
759 =  By default, this is undefined which implies zero (0) @i{fake} Ada Tasks. 
760 =  @code{CONFIGURE_MAXIMUM_FAKE_ADA_TASKS} is the number of @i{fake} Ada tasks that can be concurrently active in the system.  A @i{fake} Ada task is a non-Ada task that makes calls back into Ada code and thus implicitly uses the Ada run-time. 
761 =  None. 
762 = start of section
763 = Configuration Data Structures

